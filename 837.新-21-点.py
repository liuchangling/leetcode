#
# @lc app=leetcode.cn id=837 lang=python3
#
# [837] 新21点
#
# https://leetcode-cn.com/problems/new-21-game/description/
#
# algorithms
# Medium (25.62%)
# Likes:    145
# Dislikes: 0
# Total Accepted:    7.2K
# Total Submissions: 18.9K
# Testcase Example:  '10\n1\n10'
#
# 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
# 
# 爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。
# 每次抽取都是独立的，其结果具有相同的概率。
# 
# 当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？
# 
# 示例 1：
# 
# 输入：N = 10, K = 1, W = 10
# 输出：1.00000
# 说明：爱丽丝得到一张卡，然后停止。
# 
# 示例 2：
# 
# 输入：N = 6, K = 1, W = 10
# 输出：0.60000
# 说明：爱丽丝得到一张卡，然后停止。
# 在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。
# 
# 示例 3：
# 
# 输入：N = 21, K = 17, W = 10
# 输出：0.73278
# 
# 提示：
# 
# 
# 0 <= K <= N <= 10000
# 1 <= W <= 10000
# 如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。
# 此问题的判断限制时间已经减少。
# 
# 对于示例3 枚举了一下就有思路了。其实是倒推出来的。
#  示例3
#  16 50%
#  15 60% *.9 + a16 *.1  
#  14 70% *.8 + a15 *.1 + a16*.1
#  13 80% *.7 + .1 * (a14+a15+a16)
#  12 90% *.6 + .1 * (a13 + a14+a15+a16)
#  11 .5 + .1 * (a12~16)
#  10 .4 + .1 * (a11~16)
#  9 .3 + .1 * (a10~16)
#  8 .2 + .1 * (a9~16)
#  7 .1 + .1 * (a8~16)
#  6 .1(a7~16)
#  ....

#  从这个规律我们会发现a[i] =  min((N-i)/W, 1) * max(0,(1- (K-1-i)/W )) + .1(a[i+1]+ a[i+2]...+a[i+10])


#  这里有些问题其实。。就是后面是1111000.。。
#  官方思路很清晰:
#  dp[x] = (dp[x+1] +... +dp[x+w] )/w
#  dp[x-1] = (dp[x] +... +dp[x+w -1] )/w = dp[x] - ( dp[x+w] - dp[x] ) / w

#  这里k-1进行了一个特殊处理，不然要在for里面去计算，判断次数太多，提出来一次搞定。

# @lc code=start
class Solution:
    def new21Game(self, N: int, K: int, W: int) -> float:
        dp = [0 for x in range(N+W)]
        # 能拿到最大分值为 K+W-1， 但是大于N的部分得分为0
        for j in range(K, min(K + W - 1, N) + 1):
            dp[j] = 1


        dp[K-1] = min(N-K+1, W) / W
        for i in range(K-2, -1, -1):
            dp[i] = dp[i+1] - (dp[i+W+1] - dp[i+1]) / W

        return dp[0]


# @lc code=end


